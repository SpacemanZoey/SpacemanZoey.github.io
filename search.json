[{"title":"ZooKeeper - 读书笔记(2)","url":"/2024/04/06/ZooKeeper-读书笔记-2/"},{"title":"ZooKeeper - 读书笔记(1)","url":"/2024/04/06/ZooKeeper-读书笔记-1/","content":"最近工作中，可能有需要用到ZooKeeper，所以来恶补一下，阅读书籍为ZooKeeper - 分布式过程协同技术详解。\n\n# 第一部分 ZooKeeper的概念和基础\n\n## ZooKeeper作用\n\nZooKeeper 从文件系统API得到启发，提供了一组简单的API，使得开发人员可以实现通用的写作任务，包括选举主节点、管理组内成员关系、管理元数据等等，其服务组件运行在一组专用的服务器之上，保证了高容错性和可扩展性，在设计时需要将应用数据（真正处理的内容）和协同数据（元数据，分布式任务的协作数据）独立开，ZooKeeper是用于管理协同数据的服务。\n\n<!-- more --\n\n**ZooKeeper主线：**在分布式系统中写作多个任务，一个协作任务是指一个包含多个进程的任务，这个任务可以是为了协作或者管理竞争。\n\n**工作模式：**\n\n+ 【协作】：以主-从（master-worker）工作模式为例，从节点处于空闲状态时通知主节点可以接受工作，于是主节点就会分配任务给从节点；\n+ 【竞争】：以主-从（master-worker）工作模式中竞争主节点为例，需要实现互斥排他锁(mutual exclusion)，获取主节点的身份过程时获取锁的过程，获得主节点控制权锁的进程为主节点进程。\n\n**多个进程在同一台计算机上运行 VS 多个进程的跨计算机运行**\n\n+ 相同：同步原语相同\n+ 不同：典型的不共享环境下，不同计算机之间不共享除了网络之外的其他任何信息；\n\n**使用实例**\n\n+ Apache HBase：用于选举一个集群内的主节点，以便跟踪可用的服务器，并保存集群的元数据；\n+ Apache Kafka：用于检测崩溃，实现主题的发现，并保持主题的生产和消费状态；\n+ Apache Solr：储存集群的元数据，并协作更新元数据；\n+ Yahoo！Fetching Service：实现主节点的选举、崩溃检测和元数据存储；\n+ Facebook Messages：作为控制器，用来实现数据分片、故障恢复和服务发现等功能；\n\n**ZooKeeper客户端**\n\n+ 保障强一致性、有序性和持久性；\n+ 实现通用的同步原语的能力；\n+ 提供简单的并发处理机制；\n\n**ZooKeeper不适用的场景**\n\n+ 海量数据存储；\n\n**独立的协调组件的优势**\n\n+ 独立地设计和实现该组件，可以跨多个应用共享；\n+ 简化协作方面的工作；\n+ 系统可以独立地运行和协作组件，简化生产环境中解决实际问题的任务；\n\n**分布式系统通信**\n\n+ 通过网络进行信息交换；\n+ 读写共享存储（ZooKeeper）；\n\n**真实系统中的问题**\n\n+ **消息延迟**：消息传输可能发生任意延迟，如，发生网络拥堵，导致消息顺序混乱；\n+ **处理器性能**：操作系统的调度和超载也可能导致消息处理的任意延迟，消息延迟时间=发送端消耗的时间+传输时间+接收端的处理时间；\n+ **时钟偏移**：处理器始终会发生任意的偏移，依赖处理器始终会导致错误的决策；\n\n# 示例\n\n## 主-从应用\n\n主节点进程负责跟踪从节点状态和任务的有效性，并分配任务到从节点，对ZooKeeper来说，这个架构风格具有代表性，如选举主节点，跟踪有效的从节点，维护应用元数据；\n\n![主从应用架构](主从应用架构.jpg)\n\n**关键问题**\n\n+ **主节点崩溃**：如果主节点发送错误并失效，系统将无法分配新的任务或重新分配已失败的任务；\n+ **从节点崩溃**：已分配的任务将无法完成；\n+ **通信故障**：如果主从节点之间无法进行信息交换，从节点将无法得知新的任务分配；\n\n**主节点失效**\n\n主节点崩溃时需要备份节点接管角色，并进行故障转移，需要解决的问题有：状态恢复、脑裂（split-brain，系统中两个或者多个部分开始独立工作，导致整体行为的不一致性）\n\n**从节点失效**\n\n客户端向主节点提交任务，之后主节点将任务派发到有效的从节点中，从节点接收到派发的任务，执行完成狗向主节点报告执行状态，主节点下一步将执行结果通知给客户端。\n\n+ 主机点需要有检测从节点的崩溃的能力，需要确认从节点是否有效以便派发崩溃节点的任务；\n+ 崩溃时，从节点也许执行了部分任务，也许执行完成，但没有报告结果，如果运算过程产生了其他作用，有必要执行某些恢复过程来清楚之前的状态；\n\n**通信故障**\n\n+ **任务多次执行**：主从节点之间的网络断开，可能会导致任务被执行多次，场景：主节点M1发任务T1给从节点W1，W1获取任务锁，执行任务，然后释放锁，M1怀疑W1已经崩溃，再次派发任务T1给W2，W2获取任务锁，执行任务，然后释放锁。在这种场景下，任务会执行两次，因为W1和W2执行任务时没有步骤交错，这种情况需要依赖“仅一次”和“最多一次”的语义学，这又依赖于应用的特定处理机制，如局部变更回退能力等；\n+ 影响锁等同步原语：锁机制会阻止任务的继续执行，相应机制：\n  + 设置某些数据状态为临时状态；\n  + 定时发送存货通知，若未能及时发送通知，所有从属于这个客户端的临时状态的数据将全部被删除\n\n**主-从结构需求**\n\n+ 主节点选举：使得主节点可以给从节点分配任务；\n+ 崩溃检测：主节点必须具有检测从节点崩溃或失去连接的能力；\n+ 组成员关系管理：知道哪一个从节点可以执行任务；\n+ 元数据管理：主从节点必须通过某种可靠的方式来保存分配状态和执行状态的能力；\n\n# 分布式协作的难点\n\n理想情况下，基于异步通信的假设来设计系统，即使用的主机有可能发生时间偏移或通信故障。\n\n**CAP定律**\n\n+ 一致性（consistency）\n+ 可用性（availability）\n+ 分区容错性（Partition-tolerance）\n\nZooKeeper尽可能满足一致性和可用性，在发生网络分区时，ZooKeeper提供了只读能力。\n","tags":["补天石","zookeeper"]},{"title":"Linux程序设计-Chapter-2","url":"/2023/05/04/Linux程序设计-Chapter-2/","content":"# 管道和重定向\n\n## 重定向输出\n\n### 重定向覆盖到文件\n\n```\nls -l > lsoutput.txt\n```\n\n把ls命令输出到文件lsoutput.txt中\n\n**标准文件描述符**\n\n+ 0：程序的标准输入，重定向输入，输出原路打印\n\n  ```\n  archer@Arhcer:/mnt/d/coding/linux-studying/ChapterTwo$ ls -l 0> lsoutput.txt\n  total 0\n  -rwxrwxrwx 1 archer archer 0 May  4 16:55 lsoutput.txt\n  ```\n+ 1： 程序的标准输出，重定向输出\n\n  ```\n  archer@Arhcer:/mnt/d/coding/linux-studying/ChapterTwo$ ls -l 1> lsoutput.txt\n  ```\n+ 2：程序的标准错误输出，重定向错误输出\n\n  ```\n  archer@Arhcer:/mnt/d/coding/linux-studying/ChapterTwo$ ls -l 2> lsoutput.txt\n  total 0\n  -rwxrwxrwx 1 archer archer 0 May  4 16:56 lsoutput.txt\n  ```\n\n<!-- more -->\n\n默认情况下，重定向输出到文件，会直接覆盖该文件的内容，如果要改变默认行为，使用 `set -o noclobber`，可以阻止覆盖写入\n\n```\narcher@Arhcer:/mnt/d/coding/linux-studying/ChapterTwo$ set -o noclobber\narcher@Arhcer:/mnt/d/coding/linux-studying/ChapterTwo$ ls -l > lsoutput.txt\n-bash: lsoutput.txt: cannot overwrite existing file \n```\n\n取消该选项，使用 `set +o noclobber`\n\n```\narcher@Arhcer:/mnt/d/coding/linux-studying/ChapterTwo$ set +o noclobber\narcher@Arhcer:/mnt/d/coding/linux-studying/ChapterTwo$ ls -l > lsoutput.txt\n```\n\n### 重定向附加到文件\n\n```\nps >> lsoutput.txt\n```\n","tags":["补天石","Linux"]},{"title":"Leetcode-2293 Min Max Game","url":"/2023/01/15/leetcode-2293/","content":"# 题目\n\nYou are given a **0-indexed** integer array `nums` whose length is a power of `2`.\n\nApply the following algorithm on `nums`:\n\n1. Let `n` be the length of `nums`. If `n == 1`, **end** the process. Otherwise, **create** a new **0-indexed** integer array `newNums` of length `n / 2`.\n2. For every **even** index `i` where `0 <= i < n / 2`, **assign** the value of `newNums[i]` as `min(nums[2 * i], nums[2 * i + 1])`.\n3. For every **odd** index `i` where `0 <= i < n / 2`, **assign** the value of `newNums[i]` as `max(nums[2 * i], nums[2 * i + 1])`.\n4. **Replace** the array `nums` with `newNums`.\n5. **Repeat** the entire process starting from step 1.\n\nReturn *the last number that remains in *`nums`* after applying the algorithm.*\n\n\n<!-- more -->\n\n\n# 题目解析\n\n实际上就是一个非常简单的取最大值最小值的问题，有两种解法：递归和循环。\n\n循环：\n\n因为之后也不会再用到 `nums[i]`这个数字，在进行计算了之后，并不会再次被用到，所以可以原地修改，节省空间。\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n```go\nfunc minMaxGame(nums []int) int {\n    length := len(nums)\n\tfor length > 1 {\n\t\tlength = length / 2\n\t\tfor i := 0; i < length; i++ {\n\t\t\tif i % 2 == 0 {\n\t\t\t\tnums[i] = Min(nums[2 * i], nums[2 * i + 1])\n\t\t\t} else {\n\t\t\t\tnums[i] = Max(nums[2 * i], nums[2 * i + 1])\n\t\t\t}\n\n\t\t}\n\t}\n\treturn nums[0]\n}\n\nfunc Min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n\nfunc Max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n递归：\n\n在计算出新的数组之后，传入func，当n==1的时候返回nums[0]，其余就递归就行\n\n```go\nfunc minMaxGame(nums []int) int {\n    length := len(nums)\n\tif length == 1{\n\t\treturn nums[0]\n\t}\n\tnewNums := make([]int, length / 2)\n\tfor i := 0; i < length / 2; i++ {\n\t\tif i % 2 == 0 {\n\t\t\tnewNums[i] = Min(nums[2 * i], nums[2 * i + 1])\n\t\t} else {\n\t\t\tnewNums[i] = Max(nums[2 * i], nums[2 * i + 1])\n\t\t}\n\t}\n\treturn minMaxGame(newNums)\n}\n\nfunc Min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n\nfunc Max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n","tags":["补天石","leetcode"]},{"title":"瑞雪兆丰年","url":"/2023/01/15/2023-01-15-初雪/","content":"# 瑞雪兆丰年\n\n2023.01.15 上海迎来了这个冬季的第一场雪，起床的时候已经下得很大了，下午去完超市回来发现雪停了。。。稍微有点可惜，好在雪还没化，赶紧拎着相机往外跑。\n\n<!-- more -->\n\n\n![千门万户曈曈日，总把新桃换旧符](灯笼.jpg)\n\n![猫咪](猫咪.jpg)\n\n![桥](桥.jpg)\n\n![房子](房子.jpg)\n\n![花](花.jpg)\n","tags":["走马灯","冬日"]},{"title":"Leetcode:1801 积压订单中的订单总数","url":"/2023/01/02/leetcode-1801/","content":"由于工作语言是Go，所以就用Go来解答，刚好熟悉一下Go相关的知识，这里主要是碰到了Go实现大小堆，具体的思路已完成，Go大小堆知识待补充。\n\n<!-- more -->\n\n题目链接：https://leetcode.com/problems/number-of-orders-in-the-backlog/\n\nYou are given a 2D integer array `orders`, where each `orders[i] = [price<sub>i</sub>, amount<sub>i</sub>, orderType<sub>i</sub>]` denotes that `amount<sub>i</sub>`~ ~orders have been placed of type `orderType<sub>i</sub>` at the price `price<sub>i</sub>`. The `orderType<sub>i</sub>` is:\n\n* `0` if it is a batch of `buy` orders, or\n* `1` if it is a batch of `sell` orders.\n\nNote that `orders[i]` represents a batch of `amount<sub>i</sub>` independent orders with the same price and order type. All orders represented by `orders[i]` will be placed before all orders represented by `orders[i+1]` for all valid `i`.\n\nThere is a **backlog** that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:\n\n* If the order is a `buy` order, you look at the `sell` order with the **smallest** price in the backlog. If that `sell` order's price is **smaller than or equal to** the current `buy` order's price, they will match and be executed, and that `sell` order will be removed from the backlog. Else, the `buy` order is added to the backlog.\n* Vice versa, if the order is a `sell` order, you look at the `buy` order with the **largest** price in the backlog. If that `buy` order's price is **larger than or equal to** the current `sell` order's price, they will match and be executed, and that `buy` order will be removed from the backlog. Else, the `sell` order is added to the backlog.\n\nReturn  *the total **amount** of orders in the backlog after placing all the orders from the input* . Since this number can be large, return it **modulo** `10<sup>9</sup> + 7`.\n\n**Constraints:**\n\n* `1 <= orders.length <= 10<sup>5</sup>`\n* `orders[i].length == 3`\n* `1 <= price<sub>i</sub>, amount<sub>i</sub> <= 10<sup>9</sup>`\n* `orderType<sub>i</sub>` is either `0` or `1`.\n\n## 解题思路\n\n这是一个优先队列模拟的问题，存储当前的积压订单，在新的订单到来的时候根据类型，若来的是购买订单，则找出价格最低的销售订单，且当销售订单的价格<=购买订单的价格时，进行匹配并相应消除；反之购买订单>=销售订单，进行消除。\n\n要快速找到最小最大的订单价格，一个是插入时对slice进行sort排序，第二个就是使用大小堆进行判断，思路很简单，代码如下，主要是GO的大小堆实现卡住了我还蛮久的时间。。。相应博客指路 =>\n\n```go\nfunc getNumberOfBacklogOrders(orders [][]int) int {\n\tsHp, bHp := &sellHp{}, &buyHp{}\n\theap.Init(sHp)\n\theap.Init(bHp)\n\tfor _, o := range orders {\n\t\tprice, amount, orderType := o[0], o[1], o[2]\n\t\tswitch orderType {\n\t\tcase 0:\n\t\t\tfor amount > 0 && sHp.Len() > 0 && (*sHp)[0].price <= price {\n\t\t\t\tif (*sHp)[0].amount >= amount {\n\t\t\t\t\t(*sHp)[0].amount -= amount\n\t\t\t\t\tamount = 0\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tamount -= heap.Pop(sHp).(order).amount\n\t\t\t}\n\t\t\theap.Push(bHp, order{price, amount})\n\t\tcase 1:\n\t\t\tfor amount > 0 && bHp.Len() > 0 && (*bHp)[0].price >= price {\n\t\t\t\tif (*bHp)[0].amount >= amount {\n\t\t\t\t\t(*bHp)[0].amount -= amount\n\t\t\t\t\tamount = 0\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tamount -= heap.Pop(bHp).(order).amount\n\t\t\t}\n\t\t\theap.Push(sHp, order{price, amount})\n\t\t}\n\t}\n\tres := 0\n\tfor _, order := range *sHp {\n\t\tres += order.amount\n\t}\n\tfor _, order := range *bHp {\n\t\tres += order.amount\n\t}\n\treturn res % (1e9 + 7)\n}\n\ntype order struct{\n\tprice int\n\tamount int\n}\n\ntype sellHp []order\n\nfunc (s sellHp) Len() int{ return len(s) }\nfunc (s sellHp) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\nfunc (s sellHp) Less(i, j int) bool { return s[i].price < s[j].price }\n\nfunc (s *sellHp) Push(x interface{}) { \n\t*s = append(*s, x.(order))\n}\n\nfunc (s *sellHp) Pop() interface{} {\n\told := *s\n    n := len(old)\n    x := old[n-1]\n    *s = old[0 : n-1]\n\treturn x\n}\n\nfunc (b buyHp) Len() int { return len(b) }\nfunc (b buyHp) Swap(i, j int) { b[i], b[j] = b[j], b[i] }\nfunc (b buyHp) Less(i, j int) bool { return b[i].price > b[j].price }\n\nfunc (b *buyHp) Push(x interface{}) {\n\t*b = append(*b, x.(order))\n}\n\ntype buyHp []order\n\nfunc (b *buyHp) Pop() interface{} {\n\told := *b\n    n := len(old)\n    x := old[n-1]\n    *b = old[0 : n-1]\n    return x\n}\n```\n","tags":["补天石","leetcode"]},{"title":"新冠畅想","url":"/2022/12/25/新冠畅想/","content":"十二月起正式放开了疫情的管控，整个社会进入了放开的阵痛期。作为一个经历过上海上半年封城的人来说，现在的情况比当初的封城甚至更糟，外卖运力不足，抢不到菜，这是上半年经历的，但现在还多了一条足不出户可能都会被感染新冠。\n\n<!-- more -->\n\n家里人确认是阳性的已经有两个了，外公烧了两天，妈妈到现在烧了三天，伴随有过敏的并发症，而我本人在刚放开的时候同样的也发烧了。。。但连续四天抗原阴性，而当下核酸点乃超级传染点，健康人去了回来可能就”冠“了，生病的我，如果得的不是新冠，只怕超级加倍。\n\n感觉我的生病体验是最糟糕的，高烧很快就退下去了，然而低烧缠绵不绝，稍微动一下，可能就会在大脑里引发重大海啸，头晕恶心，更折磨的是飞流直下的腹泻，身边好友纷纷推荐好用的止泻药，尝试了蒙脱石散，”用完就有便秘感“，很棒，吃了两天还是一直拉，直到喝了粥，整个人瘦了8斤，整整五天没有碰任何荤腥，看到自己的胳膊都想咬一口尝尝肉味了。\n\n实际上，我是一个主张放开的人，但亲自体验过了新冠了之后，一周褪了一层皮，非常感谢过去三年国家对我们的保护。你说我现在还是放开派么？老老实实说我不知道。我们的防疫，不得不承认是非常有效且保护了大家的生命安全，但全世界就我们在认真防疫，就跟秋天在落叶树下烧柴火，我们釜底抽薪，奈何涓涓细流源源不断。如今国外的生活已经正常化，而我们依然保持疫情的紧急状态，内心的天平逐渐向自由倾斜，这是我放开之前的想法。而真正放开了之后，听同事说，朋友圈一刷三个朋友的家人因为新冠离世了，有一句话说得很好，对其他人来说这些离世的人只是数字，对他们来讲是真真实实的家人，而互联网上也能看到有孕妇因新冠流产、儿童/新生儿因新冠过世……这是放开之后我们所有人要承担的离别，因自由付出的代价着实有些大了。\n\n如今，已全面放开，于自身而言多锻炼身体，把自己搞得强壮一些，督促家人勤锻炼，出入洗手消毒，是我们要做的事情，好好保护自己和家人。\n","tags":["不夜侯"]},{"title":"Linux程序设计——读书笔记 Chapter 1","url":"/2022/12/11/Linux程序设计-Chapter-1/","content":"## Unix相关\n\nUnix：符合P1003，或POSIX（便携式操作系统接口）规范的操作系统，POSIX规范定义了所有必须的UNIX操作系统功能的名称、接口和行为。只有严格遵守该规范的操作系统才能被叫做Unix。目前有很多类Unix操作系统的系统，如IBM的AIX、HP的HP-UX或者Sun的Solaris。\n\n<!-- more -->\n\n### Unix哲学\n\n+ Simplicity 简单性：KISS：keep it small and simple 程序越复杂，bug也越复杂，debug也更难；\n+ Focus 集中性：one program perform one task，feature过多的program会难用且难以维护，每个program考虑尽量少的需求，不要一个program囊括所有的需求；\n+ Reusable Component 可重用组件：这里提倡简单灵活的interface和通用的代码（OS：在实际的开发中它会节约我们的人力成本，但是需要确保正确性，不然人家调用了发现，我丢，全是bug）；\n+ Filters 过滤器：用别人的输出作为自己的输入，站在别人的肩膀上开发自己的程序，也是复用性的一种体现；\n+ Open File Formats 开放的文件格式\n+ Flexibility 灵活性：需求是可变的，程序要设计得灵活才能很好地迭代，不然重构会非常频繁。\n\n## Linux\n\nLinux应用程序由两种特殊类型的文件表示：可执行文件和脚本（executables and scripts）。简单来说，可执行文件可以直接跑，但是脚本还需要解释器。\n\n比较重要的保存文件的三个path：\n\n+ /bin：二进制文件，用于启动系统的程序；\n+ /usr/bin：用户二进制文件，用户可使用的标准程序；\n+ /usr/local/bin：本地的二进制文件，特定于安装的程序\n\n一些可选的操作系统组件和第三方应用程序可以安装在/opt的子目录中（OS：像我们公司的一些log日志就是/opt/tiger/XXX/XXX/.log，包括atop查看日志也是在opt中）。\n\nLinux用(:)来分割PATH中的各个路径，但是Windows是用的(;)\n\n```\n/usr/local/bin:/bin:/usr/bin:.:/home/neil/bin:/usr/X11R6/bin\n```\n\nLinux中用的是斜杠(/)来分割directory name，但是windows用的是反斜杠(\\\\)。\n\n与众不同的Windows。。。平时工作中用的是macos和Linux，有些命令windows用不了。。泪目。。\n\n## Development System Roadmap\n\n### GCC编译\n\n-I：direct头文件，eg: gcc -I/usr/openwin/include fred.c\n\n### 共享库\n\n使用.so作为后缀来命名\n\n静态库的缺点：当你同时运行许多应用程序，并且它们都使用同一个库中的函数时，你可能会在内存中出现许多相同函数的副本，实际上在程序文件本身中也有许多副本，这个会造成内存和磁盘资源的浪费。\n\n所以使用共享库来解决静态库的这个问题\n","tags":["补天石","Linux"]},{"title":"第N次Hello World","url":"/2022/12/10/talking221210/","content":"实际上，这个个人博客已经存在了三四年了，在大学的时候一直都没有好好利用起来，写的博文乱七八糟，每开一个系列，总躲不过烂尾的命运。最近，倒也不是最近，半年前换了电脑，要把博客迁移到新机器上，可惜只能说，可惜，本拖延症ICU病患，一直拖到了今天，才让这个小铺子重新开张。\n\n<!-- more -->\n\n# Why\n\n其实这个小铺子已经在我的字典里消失很久很久了，但是最近在工作上遇到了一些需要书写文本，理清思路的场景，写着写着总觉得词不达意，写着写着别人总是读不懂，看不明白。想了想，最近一次比较正式的，咬文嚼字的长篇大论是在什么时候呢，似乎，是在半年以前？写毕业论文的时候？交出了一坨下消化道的产物，gagaga，感谢老师高抬贵手，让我毕业了。\n\n所以呢，就想寻找一些方法，让自己能够多输出一些文字，多做一些总结。于是乎，我就想起了这个关张多年的小铺子，然后动作麻利地收拾了一下，重新开张了。\n\n# What\n\n铺子是开张了，顾客的画像应该是怎么样的呢，售卖的货物又是什么呢？顾客么，大约是我自己，售卖的货物，大约是一些随手拍拍的瞬间，一些生活小记，一些阅读感悟，一些可能会被愚蠢的大脑断舍离的东西。交易的货币暂且就是时间吧！当发现自己家徒四壁的时候，进来消费消费，又变成一个小富婆了。\n\n# How\n\n铺子主人，工作日主业繁忙，心情不好的时候才来进货，尽量每周都进一次货，好让货架上有物可选。\n","tags":["不夜侯"]}]