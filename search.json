[{"title":"Leetcode-2293 Min Max Game","url":"/2023/01/15/leetcode-2293/","content":"# 题目\n\nYou are given a **0-indexed** integer array `nums` whose length is a power of `2`.\n\nApply the following algorithm on `nums`:\n\n1. Let `n` be the length of `nums`. If `n == 1`, **end** the process. Otherwise, **create** a new **0-indexed** integer array `newNums` of length `n / 2`.\n2. For every **even** index `i` where `0 <= i < n / 2`, **assign** the value of `newNums[i]` as `min(nums[2 * i], nums[2 * i + 1])`.\n3. For every **odd** index `i` where `0 <= i < n / 2`, **assign** the value of `newNums[i]` as `max(nums[2 * i], nums[2 * i + 1])`.\n4. **Replace** the array `nums` with `newNums`.\n5. **Repeat** the entire process starting from step 1.\n\nReturn *the last number that remains in *`nums`* after applying the algorithm.*\n\n\n<!-- more -->\n\n\n# 题目解析\n\n实际上就是一个非常简单的取最大值最小值的问题，有两种解法：递归和循环。\n\n循环：\n\n因为之后也不会再用到 `nums[i]`这个数字，在进行计算了之后，并不会再次被用到，所以可以原地修改，节省空间。\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n```go\nfunc minMaxGame(nums []int) int {\n    length := len(nums)\n\tfor length > 1 {\n\t\tlength = length / 2\n\t\tfor i := 0; i < length; i++ {\n\t\t\tif i % 2 == 0 {\n\t\t\t\tnums[i] = Min(nums[2 * i], nums[2 * i + 1])\n\t\t\t} else {\n\t\t\t\tnums[i] = Max(nums[2 * i], nums[2 * i + 1])\n\t\t\t}\n\n\t\t}\n\t}\n\treturn nums[0]\n}\n\nfunc Min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n\nfunc Max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n递归：\n\n在计算出新的数组之后，传入func，当n==1的时候返回nums[0]，其余就递归就行\n\n```go\nfunc minMaxGame(nums []int) int {\n    length := len(nums)\n\tif length == 1{\n\t\treturn nums[0]\n\t}\n\tnewNums := make([]int, length / 2)\n\tfor i := 0; i < length / 2; i++ {\n\t\tif i % 2 == 0 {\n\t\t\tnewNums[i] = Min(nums[2 * i], nums[2 * i + 1])\n\t\t} else {\n\t\t\tnewNums[i] = Max(nums[2 * i], nums[2 * i + 1])\n\t\t}\n\t}\n\treturn minMaxGame(newNums)\n}\n\nfunc Min(a, b int) int {\n    if a > b {\n        return b\n    }\n    return a\n}\n\nfunc Max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n","tags":["补天石","leetcode"]},{"title":"瑞雪兆丰年","url":"/2023/01/15/2023-01-15-初雪/","content":"# 瑞雪兆丰年\n\n2023.01.15 上海迎来了这个冬季的第一场雪，起床的时候已经下得很大了，下午去完超市回来发现雪停了。。。稍微有点可惜，好在雪还没化，赶紧拎着相机往外跑。\n\n<!-- more -->\n\n\n![千门万户曈曈日，总把新桃换旧符](灯笼.jpg)\n\n![猫咪](猫咪.jpg)\n\n![桥](桥.jpg)\n\n![房子](房子.jpg)\n\n![花](花.jpg)\n","tags":["走马灯","冬日"]},{"title":"Leetcode:1801 积压订单中的订单总数","url":"/2023/01/02/leetcode-1801/","content":"由于工作语言是Go，所以就用Go来解答，刚好熟悉一下Go相关的知识，这里主要是碰到了Go实现大小堆，具体的思路已完成，Go大小堆知识待补充。\n\n<!-- more -->\n\n题目链接：https://leetcode.com/problems/number-of-orders-in-the-backlog/\n\nYou are given a 2D integer array `orders`, where each `orders[i] = [price<sub>i</sub>, amount<sub>i</sub>, orderType<sub>i</sub>]` denotes that `amount<sub>i</sub>`~ ~orders have been placed of type `orderType<sub>i</sub>` at the price `price<sub>i</sub>`. The `orderType<sub>i</sub>` is:\n\n* `0` if it is a batch of `buy` orders, or\n* `1` if it is a batch of `sell` orders.\n\nNote that `orders[i]` represents a batch of `amount<sub>i</sub>` independent orders with the same price and order type. All orders represented by `orders[i]` will be placed before all orders represented by `orders[i+1]` for all valid `i`.\n\nThere is a **backlog** that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:\n\n* If the order is a `buy` order, you look at the `sell` order with the **smallest** price in the backlog. If that `sell` order's price is **smaller than or equal to** the current `buy` order's price, they will match and be executed, and that `sell` order will be removed from the backlog. Else, the `buy` order is added to the backlog.\n* Vice versa, if the order is a `sell` order, you look at the `buy` order with the **largest** price in the backlog. If that `buy` order's price is **larger than or equal to** the current `sell` order's price, they will match and be executed, and that `buy` order will be removed from the backlog. Else, the `sell` order is added to the backlog.\n\nReturn  *the total **amount** of orders in the backlog after placing all the orders from the input* . Since this number can be large, return it **modulo** `10<sup>9</sup> + 7`.\n\n**Constraints:**\n\n* `1 <= orders.length <= 10<sup>5</sup>`\n* `orders[i].length == 3`\n* `1 <= price<sub>i</sub>, amount<sub>i</sub> <= 10<sup>9</sup>`\n* `orderType<sub>i</sub>` is either `0` or `1`.\n\n## 解题思路\n\n这是一个优先队列模拟的问题，存储当前的积压订单，在新的订单到来的时候根据类型，若来的是购买订单，则找出价格最低的销售订单，且当销售订单的价格<=购买订单的价格时，进行匹配并相应消除；反之购买订单>=销售订单，进行消除。\n\n要快速找到最小最大的订单价格，一个是插入时对slice进行sort排序，第二个就是使用大小堆进行判断，思路很简单，代码如下，主要是GO的大小堆实现卡住了我还蛮久的时间。。。相应博客指路 =>\n\n```go\nfunc getNumberOfBacklogOrders(orders [][]int) int {\n\tsHp, bHp := &sellHp{}, &buyHp{}\n\theap.Init(sHp)\n\theap.Init(bHp)\n\tfor _, o := range orders {\n\t\tprice, amount, orderType := o[0], o[1], o[2]\n\t\tswitch orderType {\n\t\tcase 0:\n\t\t\tfor amount > 0 && sHp.Len() > 0 && (*sHp)[0].price <= price {\n\t\t\t\tif (*sHp)[0].amount >= amount {\n\t\t\t\t\t(*sHp)[0].amount -= amount\n\t\t\t\t\tamount = 0\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tamount -= heap.Pop(sHp).(order).amount\n\t\t\t}\n\t\t\theap.Push(bHp, order{price, amount})\n\t\tcase 1:\n\t\t\tfor amount > 0 && bHp.Len() > 0 && (*bHp)[0].price >= price {\n\t\t\t\tif (*bHp)[0].amount >= amount {\n\t\t\t\t\t(*bHp)[0].amount -= amount\n\t\t\t\t\tamount = 0\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tamount -= heap.Pop(bHp).(order).amount\n\t\t\t}\n\t\t\theap.Push(sHp, order{price, amount})\n\t\t}\n\t}\n\tres := 0\n\tfor _, order := range *sHp {\n\t\tres += order.amount\n\t}\n\tfor _, order := range *bHp {\n\t\tres += order.amount\n\t}\n\treturn res % (1e9 + 7)\n}\n\ntype order struct{\n\tprice int\n\tamount int\n}\n\ntype sellHp []order\n\nfunc (s sellHp) Len() int{ return len(s) }\nfunc (s sellHp) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\nfunc (s sellHp) Less(i, j int) bool { return s[i].price < s[j].price }\n\nfunc (s *sellHp) Push(x interface{}) { \n\t*s = append(*s, x.(order))\n}\n\nfunc (s *sellHp) Pop() interface{} {\n\told := *s\n    n := len(old)\n    x := old[n-1]\n    *s = old[0 : n-1]\n\treturn x\n}\n\nfunc (b buyHp) Len() int { return len(b) }\nfunc (b buyHp) Swap(i, j int) { b[i], b[j] = b[j], b[i] }\nfunc (b buyHp) Less(i, j int) bool { return b[i].price > b[j].price }\n\nfunc (b *buyHp) Push(x interface{}) {\n\t*b = append(*b, x.(order))\n}\n\ntype buyHp []order\n\nfunc (b *buyHp) Pop() interface{} {\n\told := *b\n    n := len(old)\n    x := old[n-1]\n    *b = old[0 : n-1]\n    return x\n}\n```\n","tags":["补天石","leetcode"]},{"title":"积分游戏","url":"/2023/01/02/积分游戏/","content":"为了能够实现自己的年度目标，设立了一个积分游戏，1分等于20￥，相当于一个存钱罐，游戏消遣的东西，只能用积分换取。\n\n<!-- more -->\n\n## 加分\n\n工作：+1/未见过的新bug，且独自处理；+5 新需求无缺陷；+1正常按时完成需求；+1 额外技术方案/调研；\n\n专业书：+3/章节，看完整本bonus+10，若书籍为英文各个项目+0.5bonus；\n\n阅读：+1/章节，看完整本bonus+5；\n\n技术博客写作：+1/篇；\n\nLeetcode：+0.5/easy，+1/mid，+2/hard，多解法每种+0.5；\n\n英语单词：+1/20词，若一个月后还记得+1/20词；\n\n吉它曲：+2/段落，流利完成整首歌bonus+7；\n\n健身：+2/半小时；\n\n起床/睡觉：+1/8点前起床；+1/12点半前睡觉，每早半个小时bonus+1，周末/假期9点前起床，1点前睡觉；\n\n扫街：+0.5/张，修完的；\n\n## 减分\n\n工作：-1延期/天；-1/超出规定缺陷；-1/bug未能解决；-3/出notice/fatal；\n\n起床/睡觉：-1/规定时间每晚1个小时；\n\n看电视、玩游戏、玩手机：每天限定半小时，每多半小时-0.5，周末三小时，一周娱乐时间为8.5，前面有没用完的可以除2结算至下周；\n","tags":["不夜侯"]},{"title":"新年快乐 2023","url":"/2023/01/02/新年快乐/","content":"今天是2023年的第二天，理论上这个回顾过去展望未来的文章，应该在2022-2023交会之际完成，然而拖延症本症一直拖到了今天晚上，假期的最后一天，再不写就要到下周了=。=\n\n<!-- more -->\n\n2022年，是相当魔幻的一年了，年头陷在了找工作的焦虑中，好不容易找到了工作开始实习，结果上海疫情又被封了小半年，哦，对了当中还夹杂了毕业论文。而到了年中和年末，忙忙碌碌，加班赶工是常态。将将2022年尾巴了，结果又直接放开了，然后身边大家纷纷冠了。这么一想，其实2022不算虚度，至少也算得上精彩。\n\n但实际上，我自己对2022年还是不算满意的，一是缺了毕业旅行；二是工作上做事粗糙，在最开始的时候思考过于简单，而且感觉我本身的基础有些薄弱，但是周末时而被未完成的工作绊住时而贪玩，一整年只看了github相关的书本，是我过于懒散了；三是阅读时间不够，想到小的时候，端起书本就能过一整天，反而到现在年纪大了却静不下心来看书，去年拖拖拉拉看了两个半本的书，肚子里没啥墨水，说话没啥营养。\n\n跟个风列一下23年的计划，年中复盘调整，以及到了年末看看是否完成。\n\n---\n\n工作\n\n+ [ ] 每一个新需求缺陷数 <= 3；\n+ [ ] 全年无重大工程质量问题，无notice，无fatal；\n+ [ ] 全年没有因自身原因/工程质量问题，延期；\n+ [ ] 新来oncall独立处理；\n+ [ ] 新需求做好全面调研，避免因为工程质量问题，代码活不过两个月；\n\n---\n\n生活\n\n* [ ] 旅游 >=2 次；\n* [ ] 学会 >= 2首吉他曲，弹唱/指弹，时长>3min；\n* [ ] 每个季度扫街一次，扫完街后，修图出图 >=5；\n* [ ] 装修新家，关心细节，并完成智能家居建设；\n\n---\n\n学习\n\n* [ ] 读完>=4本专业书，且一本为架构相关的书籍；\n* [ ] 完成技术博客写作，技术博客周更，至少两周更完完整的一篇读书笔记；\n* [ ] 每周Leetcode完成大于两道，并完成思路解析博客写作；\n* [ ] 英语提升，完成一本托福/雅思书（just随便学学）；\n\n---\n\n健康\n\n* [ ] 身体健康的情况下，每周运动8km；\n* [ ] 12点前睡觉，8点起床；\n* [ ] 羽毛球学习，离开新手班，可以正常组队打球；\n\n为了顺利完成这些目标，我给自己列了一个积分游戏（昨天小红书上看来的hhh），每周清算积分，看看完成了多少。\n\n以上新年感想，写于新年第二天。\n\n2023.01.02 写于上海 by竹杖芒鞋\n","tags":["不夜侯"]},{"title":"新冠畅想","url":"/2022/12/25/新冠畅想/","content":"十二月起正式放开了疫情的管控，整个社会进入了放开的阵痛期。作为一个经历过上海上半年封城的人来说，现在的情况比当初的封城甚至更糟，外卖运力不足，抢不到菜，这是上半年经历的，但现在还多了一条足不出户可能都会被感染新冠。\n\n<!-- more -->\n\n家里人确认是阳性的已经有两个了，外公烧了两天，妈妈到现在烧了三天，伴随有过敏的并发症，而我本人在刚放开的时候同样的也发烧了。。。但连续四天抗原阴性，而当下核酸点乃超级传染点，健康人去了回来可能就”冠“了，生病的我，如果得的不是新冠，只怕超级加倍。\n\n感觉我的生病体验是最糟糕的，高烧很快就退下去了，然而低烧缠绵不绝，稍微动一下，可能就会在大脑里引发重大海啸，头晕恶心，更折磨的是飞流直下的腹泻，身边好友纷纷推荐好用的止泻药，尝试了蒙脱石散，”用完就有便秘感“，很棒，吃了两天还是一直拉，直到喝了粥，整个人瘦了8斤，整整五天没有碰任何荤腥，看到自己的胳膊都想咬一口尝尝肉味了。\n\n实际上，我是一个主张放开的人，但亲自体验过了新冠了之后，一周褪了一层皮，非常感谢过去三年国家对我们的保护。你说我现在还是放开派么？老老实实说我不知道。我们的防疫，不得不承认是非常有效且保护了大家的生命安全，但全世界就我们在认真防疫，就跟秋天在落叶树下烧柴火，我们釜底抽薪，奈何涓涓细流源源不断。如今国外的生活已经正常化，而我们依然保持疫情的紧急状态，内心的天平逐渐向自由倾斜，这是我放开之前的想法。而真正放开了之后，听同事说，朋友圈一刷三个朋友的家人因为新冠离世了，有一句话说得很好，对其他人来说这些离世的人只是数字，对他们来讲是真真实实的家人，而互联网上也能看到有孕妇因新冠流产、儿童/新生儿因新冠过世……这是放开之后我们所有人要承担的离别，因自由付出的代价着实有些大了。\n\n如今，已全面放开，于自身而言多锻炼身体，把自己搞得强壮一些，督促家人勤锻炼，出入洗手消毒，是我们要做的事情，好好保护自己和家人。\n","tags":["不夜侯"]},{"title":"Linux程序设计——读书笔记 Chapter 1","url":"/2022/12/11/Linux程序设计-Chapter-1/","content":"## Unix相关\n\nUnix：符合P1003，或POSIX（便携式操作系统接口）规范的操作系统，POSIX规范定义了所有必须的UNIX操作系统功能的名称、接口和行为。只有严格遵守该规范的操作系统才能被叫做Unix。目前有很多类Unix操作系统的系统，如IBM的AIX、HP的HP-UX或者Sun的Solaris。\n\n<!-- more -->\n\n### Unix哲学\n\n+ Simplicity 简单性：KISS：keep it small and simple 程序越复杂，bug也越复杂，debug也更难；\n+ Focus 集中性：one program perform one task，feature过多的program会难用且难以维护，每个program考虑尽量少的需求，不要一个program囊括所有的需求；\n+ Reusable Component 可重用组件：这里提倡简单灵活的interface和通用的代码（OS：在实际的开发中它会节约我们的人力成本，但是需要确保正确性，不然人家调用了发现，我丢，全是bug）；\n+ Filters 过滤器：用别人的输出作为自己的输入，站在别人的肩膀上开发自己的程序，也是复用性的一种体现；\n+ Open File Formats 开放的文件格式\n+ Flexibility 灵活性：需求是可变的，程序要设计得灵活才能很好地迭代，不然重构会非常频繁。\n\n## Linux\n\nLinux应用程序由两种特殊类型的文件表示：可执行文件和脚本（executables and scripts）。简单来说，可执行文件可以直接跑，但是脚本还需要解释器。\n\n比较重要的保存文件的三个path：\n\n+ /bin：二进制文件，用于启动系统的程序；\n+ /usr/bin：用户二进制文件，用户可使用的标准程序；\n+ /usr/local/bin：本地的二进制文件，特定于安装的程序\n\n一些可选的操作系统组件和第三方应用程序可以安装在/opt的子目录中（OS：像我们公司的一些log日志就是/opt/tiger/XXX/XXX/.log，包括atop查看日志也是在opt中）。\n\nLinux用(:)来分割PATH中的各个路径，但是Windows是用的(;)\n\n```\n/usr/local/bin:/bin:/usr/bin:.:/home/neil/bin:/usr/X11R6/bin\n```\n\nLinux中用的是斜杠(/)来分割directory name，但是windows用的是反斜杠(\\\\)。\n\n与众不同的Windows。。。平时工作中用的是macos和Linux，有些命令windows用不了。。泪目。。\n\n## Development System Roadmap\n\n### GCC编译\n\n-I：direct头文件，eg: gcc -I/usr/openwin/include fred.c\n\n### 共享库\n\n使用.so作为后缀来命名\n\n静态库的缺点：当你同时运行许多应用程序，并且它们都使用同一个库中的函数时，你可能会在内存中出现许多相同函数的副本，实际上在程序文件本身中也有许多副本，这个会造成内存和磁盘资源的浪费。\n\n所以使用共享库来解决静态库的这个问题\n","tags":["补天石","Linux"]},{"title":"第N次Hello World","url":"/2022/12/10/talking221210/","content":"实际上，这个个人博客已经存在了三四年了，在大学的时候一直都没有好好利用起来，写的博文乱七八糟，每开一个系列，总躲不过烂尾的命运。最近，倒也不是最近，半年前换了电脑，要把博客迁移到新机器上，可惜只能说，可惜，本拖延症ICU病患，一直拖到了今天，才让这个小铺子重新开张。\n\n<!-- more -->\n\n# Why\n\n其实这个小铺子已经在我的字典里消失很久很久了，但是最近在工作上遇到了一些需要书写文本，理清思路的场景，写着写着总觉得词不达意，写着写着别人总是读不懂，看不明白。想了想，最近一次比较正式的，咬文嚼字的长篇大论是在什么时候呢，似乎，是在半年以前？写毕业论文的时候？交出了一坨下消化道的产物，gagaga，感谢老师高抬贵手，让我毕业了。\n\n所以呢，就想寻找一些方法，让自己能够多输出一些文字，多做一些总结。于是乎，我就想起了这个关张多年的小铺子，然后动作麻利地收拾了一下，重新开张了。\n\n# What\n\n铺子是开张了，顾客的画像应该是怎么样的呢，售卖的货物又是什么呢？顾客么，大约是我自己，售卖的货物，大约是一些随手拍拍的瞬间，一些生活小记，一些阅读感悟，一些可能会被愚蠢的大脑断舍离的东西。交易的货币暂且就是时间吧！当发现自己家徒四壁的时候，进来消费消费，又变成一个小富婆了。\n\n# How\n\n铺子主人，工作日主业繁忙，心情不好的时候才来进货，尽量每周都进一次货，好让货架上有物可选。\n","tags":["不夜侯"]}]